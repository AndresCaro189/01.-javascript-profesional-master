<!DOCTYPE html>
<html>
  <head>
    <title>Closures</title>
  </head>

  <body>
    <a href="/ejercicios/">Go back</a>
    <p><em>Abre la consola</em></p>

    <script>
      /* Closures Son funciones que regresan una función o un objeto con funciones que mantienen las variables que fueron declaradas
      fuera de su scope.
      Los closures nos sirven para tener algo parecido a variables privadas, característica que no tiene JavaScript por default. Es
      decir encapsulan variables que no pueden ser modificadas directamente por otros objetos, sólo por funciones pertenecientes al
      mismo.*/

      //printColor
      //IIFE Una expresión de función invocada de inmediato es un lenguaje de lenguaje de programación JavaScript que produce un alcance léxico utilizando el alcance de la función de JavaScript. 
      /*la variable color no estará en un ámbito global sino funcional. Cuando combinamos un scope con una función sucede esto que ya
      hicimos, el famoso clousure. La función que se encuentra en su interior puede acceder a la variable.*/
            /*
            (function() {
              let color = 'green';

              function printColor() {
                  console.log(color);
              }

              printColor();
            })();
            */
      // Funciones que regresan funciones
      /*Acá pasa algo interesante, la función que está dentro de makeColorPrinter() recuerda el valor de colorMessage aún cuando es llamado en la variable0
      greenColorPrinter, está afuera de su scope pero aún lo recuerda. A esto se le llama closure, una funcionalidad que el lenguaje no
      trae por sí solo, logramos que se memorizara el scope. El feature que creamos se llama variables privadas.*/
            /*
            function makeColorPrinter(color) {
              let colorMessage = `The color is ${color}`;

              return function() {
                console.log(colorMessage);
              };
            }

            let greenColorPrinter = makeColorPrinter('green');
            console.log(greenColorPrinter());
            */
      //variables "privadas"
      /*¿Qué sucede acá? Ahora tenemos una variable privada por que si accedemos a counter.count no nos dará ningún valor, si
      usamos console.log(counter.count) no nos arrojará nada, pero sí tenemos las tres funciones declaradas disponibles; increase;
      decrease; getCount. Para acceder al valor de count lo tenemos que hacer usando la función getCount que sí
      tenemos disponible. Si no queremos que nuestra variable sea reescrita podemos usar la variable privada usando funciones.*/
            /* //Primera Parte
            const counter = {
              count: 3,
            };
            console.log(counter.count);
            counter.count = 99;
            console.log(counter.count);
            */
            //Segunda Parte
            /*
            function makeCounter(n) {
              let count = n;
              return {
                increase: function() {
                  count = count + 1;
                },
                decrease: function() {
                  count = count - 1;
                },
                getCount: function() {
                  return count;
                },
              };
            }

            let counter = makeCounter(7);

            console.log('The count is:', counter.getCount());
            counter.increase();
            console.log('The count is:', counter.getCount());
            counter.decrease();
            counter.decrease();
            counter.decrease();
            counter.decrease();
            console.log('The count is:', counter.getCount());

            counter.count = 0;
            console.log('The count is:', counter.getCount());
            */
    </script>
  </body>
</html>
